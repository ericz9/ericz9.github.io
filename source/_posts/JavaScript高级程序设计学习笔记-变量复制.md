---
title: JavaScript高级程序设计学习笔记 - 变量复制
date: 2020-12-22 09:59:11
tags: JavaScript高级程序设计学习笔记
---
我们已经知道，ECMAScript 中包含两种类型的数据：原始值和引用值。其中，原始值按值访问，引用值按引用访问。

# 按值访问和按引用访问
首先我们需要了解原始值和引用值的内存分配机制：
* 原始值：存储在栈（stack）中
* 引用值：有指针和实际值，实际的值存储在堆（heap）中，指针存储在栈中，它指向实际的值所存储的地址

而不同的内存分配，也就出现了上面所说的两种不同的访问机制

原始值我们可以直接从栈中获取，这就是按值访问

而引用值，我们需要先在栈中得到它所指向的实际地址，然后根据该地址获得实际的值，这就是按引用访问

# 只有按值传递
**先说结论，所有变量的复制，都是按值传递，没有按引用传递一说**

* 复制原始值：产生一个副本，它们没有任何关系，完全独立，互不干扰
* 复制引用值：
  * 实际就是复制指针，产生一个副本，两个指针之间没有任何关系，完全独立，互不干扰
  * 两个指针的值都是该引用值的实际地址

```javascript
let foo = { name: 'foo' };
let bar = foo;
console.log(foo === bar); // true

// 因为两个指针都指向同一个地址，所以改变 bar 的 name，foo 中也会同步改变
bar.name = 'foo changed';
console.log(foo.name); // foo changed
console.log(bar.name); // foo changed

// 因为是按值传递，两个指针相互独立，给 bar 赋值，会重新产生一个指针，指向 bar 实际的值的地址
// 如果是按引用传递，foo 也应被改变才对
bar = { name: 'bar' };
console.log(foo.name); // foo changed
console.log(bar.name); // bar
```

> 理解 JS 中只有按值传递的重点在于，复制原始值时会在栈中产生一个实际值的副本，复制引用值时会在栈中产生一个指针的副本（指针是独立的，但都指向实际的值所在堆中的同一个地址）。**函数的参数传递也是如此**。