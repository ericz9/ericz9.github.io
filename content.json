{"meta":{"title":"ericz9's blog","subtitle":"再出发","description":null,"author":"ericz9","url":"http://ericz9.github.io","root":"/"},"pages":[{"title":"Categories","date":"2020-12-16T03:10:00.000Z","updated":"2020-12-16T03:10:50.617Z","comments":false,"path":"categories/index.html","permalink":"http://ericz9.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2015-08-16T06:58:08.000Z","updated":"2020-12-16T03:11:01.852Z","comments":true,"path":"about/index.html","permalink":"http://ericz9.github.io/about/index.html","excerpt":"HipaperA fashional newspaper, blog theme for Hexo. ☞ Preview Demo | 查看中文使用文档","text":"HipaperA fashional newspaper, blog theme for Hexo. ☞ Preview Demo | 查看中文使用文档 Installation Get it from GitHub 1$ git clone https://github.com/iTimeTraveler/hexo-theme-hipaper.git themes/hipaper Enable Modify theme setting in _config.yml to hipaper. 1234# Extensions## Plugins: http:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F;## Themes: http:&#x2F;&#x2F;hexo.io&#x2F;themes&#x2F;theme: hipaper Update 12$ cd themes/hipaper$ git pull FeaturesLogo: Image or TextYou can set a image as your logo instead of original text title. Like this: just enable avatar field in hipaper/_config.yml. 12345678# Put your avatar.jpg into `hexo-site/themes/hipaper/source/` directory.# url is target link (E.g. `url: https://hexo.io/logo.svg` or `url: css/images/mylogo.jpg`)avatar: enable: true width: 124 height: 124 bottom: 10 url: https://hexo.io/logo.svg Code HighlightHipaper use Tomorrow Theme for your code block. We have six options in total: default, normal, night, night blue, night bright, night eighties Above preview picture is default theme. the image below show other five Highlight themes. Modify highlight_theme in hipaper/_config.yml. 12345# Code Highlight theme# Available value:# default | normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: default SidebarYou can put your sidebar in left side, right side or bottom of your site by editing sidebar setting.Hipaper provides 7 built-in widgets: search social recent_posts category tag tagcloud archive All of them are enabled by default. You can edit them in widget setting. SearchHipaper use Insight Search to help you search anything inside your site without any third-party plugin. 12345# Searchsearch: insight: true # you need to install `hexo-generator-json-content` before using Insight Search swiftype: # enter swiftype install key here baidu: false # you need to disable other search engines to use Baidu search, options: true, false Attention: You need to install hexo-generator-json-content before using Insight Search. 1$ npm install -S hexo-generator-json-content FancyboxHipaper uses Fancybox to showcase your photos. You can use Markdown syntax or fancybox tag plugin to add your photos. 123![img caption](img url)&#123;% fancybox img_url [img_thumbnail] [img_caption] %&#125; Comment supportHipaper has native support for DuoShuo &amp; Disqus comment systems. Modify the following snippets to Hipaper hipaper/_config.yml: 123# comment ShortName, you can choose only ONE to display.duoshuo_shortname: iTimeTravelerdisqus_shortname: Browser support ContributingAll kinds of contributions (enhancements, new features, documentation &amp; code improvements, issues &amp; bugs reporting) are welcome. Looking forward to your pull request. Special thanks to ATHEMES, who designed the original theme FASHIONISTA for Wordpress. LicenseHipaper is under the MIT license. See the LICENSE file for details."},{"title":"Tags","date":"2020-12-16T03:10:00.000Z","updated":"2020-12-16T03:10:55.759Z","comments":true,"path":"tags/index.html","permalink":"http://ericz9.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JavaScript高级程序设计学习笔记 - 数据类型(Symbol)","slug":"JavaScript高级程序设计学习笔记-数据类型-Symbol","date":"2020-12-21T01:50:17.000Z","updated":"2020-12-21T06:49:26.635Z","comments":true,"path":"2020/12/21/JavaScript高级程序设计学习笔记-数据类型-Symbol/","link":"","permalink":"http://ericz9.github.io/2020/12/21/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-Symbol/","excerpt":"","text":"Symbol（符号） 是原始值，其实例是唯一、不可变的，它的用途是用做对象的非字符串形式的属性，而不会产生同名冲突。 符号初始化12345678// 符号需要使用 Symbol() 函数初始化let genericSymbol = Symbol();let otherGenericSymbol = Symbol();console.log(genericSymbol == otherGenericSymbol); // false let fooSymbol = Symbol(&#x27;foo&#x27;);let otherFooSymbol = Symbol(&#x27;foo&#x27;);console.log(fooSymbol == otherFooSymbol); // false 全局符号使用 Symbol.for() 创建全局符号，它是一个幂等操作。 123let globalSymbol = Symbol.for(&#x27;foo&#x27;); // 创建全局符号let otherGlobalSymbol = Symbol.for(&#x27;foo&#x27;); // 重用已定义的全局符号console.log(globalSymbol === otherGlobalSymbol); // true 符号属性12345678910111213141516171819202122232425let fooSymbol = Symbol(&#x27;foo&#x27;);let barSymbol = Symbol(&#x27;bar&#x27;);let bazSymbol = Symbol(&#x27;baz&#x27;);let quxSymbol = Symbol(&#x27;qux&#x27;);let o = &#123; foo: &#x27;foo&#x27;, [fooSymbol]: &#x27;foo symbol&#x27;&#125;;Object.defineProperty(o, barSymbol, &#123; value: &#x27;bar symbol&#x27; &#125;);Object.defineProperties(o, &#123; [bazSymbol]: &#123; value: &#x27;baz symbol&#x27; &#125;, [quxSymbol]: &#123; value: &#x27;qux symbol&#x27; &#125;&#125;);// 返回常规属性console.log(Object.getOwnPropertyNames(o)); // [&#x27;foo&#x27;]// 返回符号属性console.log(Object.getOwnPropertySymbols(o)); // [Symbol(foo), Symbol(bar), Symbol(baz), Symbol(qux)]// 返回常规属性和符号属性console.log(Reflect.ownKeys(o)); // [&quot;foo&quot;, Symbol(foo), Symbol(bar), Symbol(baz), Symbol(qux)] 常用内置符号内置符号就是全局函数 Symbol 的普通字符串属性，指向一个符号的实例，它们最重要的用途是方便开发者重新定义，从而改变原生结构行为。 Symbol.asyncIterator 一个方法，该方法返回对象默认的 AsyncIterator。由 for-await-of 语句使用 Symbol.hasInstance 一个方法，该方法决定一个构造器对象是否认可一个对象是它的实例。由 instanceof 操作符使用 在 ES6 中，instanceof 操作符会使用 Symbol.hasInstance 函数来确定关系，它定义在 Function 的原型上，因此可以在类的静态方法中定义 12345678class Foo &#123; static [Symbol.hasInstance]() &#123; return false; &#125;&#125;let foo = new Foo();console.log(foo instanceof Foo); // false Symbol.isConcatSpreadable 一个布尔值，如果是 true，则意味着对象应该用 Array.prototype.concat()打平其数组元素 12345let foo = [&#x27;foo&#x27;];let bar = [&#x27;bar&#x27;];bar[Symbol.isConcatSpreadable] = false;console.log(foo.concat(bar)); // [&#x27;foo&#x27;, Array(1)] Symbol.iterator 一个方法，该方法返回对象默认的迭代器。由 for-of 语句使用 Symbol.match 一个正则表达式方法，该方法用正则表达式去匹配字符串。由 String.prototype.match()方法使用 12345678910111213141516console.log(&#x27;foobar&#x27;.match(/bar/)); // [&quot;bar&quot;, index: 3, input: &quot;foobar&quot;, groups: undefined]class StringMatcher &#123; constructor(str) &#123; this.str = str; &#125; /** * 重新定义 Symbol.match 函数，从而让 match() 方法可以使用非正则表达式实例 * @param &#123;String&#125; target 调用 match() 方法的字符串 */ [Symbol.match](target) &#123; return target.includes(this.str); &#125;&#125;console.log(&#x27;foobar&#x27;.match(new StringMatcher(&#x27;bar&#x27;))); // true Symbol.replace 一个正则表达式方法，该方法替换一个字符串中匹配的子串。由 String.prototype.replace()方法使用 123456789101112131415class StringReplacer &#123; constructor(str) &#123; this.str = str; &#125; /** * 重新定义 Symbol.replace 函数，从而让 replace() 方法可以使用非正则表达式实例 * @param &#123;String&#125; target 调用 replace() 方法的字符串 * @param &#123;String&#125; replacement 被替换后的值 */ [Symbol.replace](target, replacement) &#123; return target.split(this.str).join(replacement); &#125;&#125;console.log(&#x27;barfoobaz&#x27;.replace(new StringReplacer(&#x27;foo&#x27;), &#x27;qux&#x27;)); // &quot;barquxbaz&quot; Symbol.search 一个正则表达式方法，该方法返回字符串中匹配正则表达式的索引。由 String.prototype.search()方法使用 1234567891011121314class StringSearcher &#123; constructor(str) &#123; this.str = str; &#125; /** * 重新定义 Symbol.search 函数，从而让 search() 方法可以使用非正则表达式实例 * @param &#123;String&#125; target 调用 search() 方法的字符串 */ [Symbol.search](target) &#123; return target.indexOf(this.str); &#125;&#125;console.log(&#x27;foobar&#x27;.search(new StringSearcher(&#x27;foo&#x27;))); // 0 Symbol.species 一个函数值，该函数作为创建派生对象的构造函数 它的意义在于，子类返回基类的实例，而非子类的实例 1234567891011class Foo extends Promise &#123;&#125;class Bar extends Promise &#123; // 指向基类 Promise 的实例 static get [Symbol.species]() &#123; return Promise; &#125;&#125;console.log(new Foo(r =&gt; r()).then(v =&gt; v) instanceof Foo) // trueconsole.log(new Bar(r =&gt; r()).then(v =&gt; v) instanceof Bar) // false Symbol.split 一个正则表达式方法，该方法在匹配正则表达式的索引位置拆分字符串。由 String.prototype.split()方法使用 1234567891011121314class StringSplitter &#123; constructor(str) &#123; this.str = str; &#125; /** * 重新定义 Symbol.split 函数，从而让 split() 方法可以使用非正则表达式实例 * @param &#123;String&#125; target 调用 split() 方法的字符串 */ [Symbol.split](target) &#123; return target.split(this.str); &#125;&#125;console.log(&#x27;barfoobaz&#x27;.split(new StringSplitter(&#x27;foo&#x27;))); // [&quot;bar&quot;, &quot;baz&quot;] Symbol.toPrimitive 一个方法，该方法将对象转换为相应的原始值。由 ToPrimitive 抽象操作使用 很多内置操作的场景下，会将对象强制转换为原始值，这时候我们可以使用该内置符号改变默认行为 12345678910111213141516171819202122232425class Bar &#123; constructor() &#123; // 支持三种模式（string、number、default） this[Symbol.toPrimitive] = function(hint) &#123; switch (hint) &#123; // 该场合需转换成数值 case &#x27;number&#x27;: return 3; // 该场合需转换成字符串 case &#x27;string&#x27;: return &#x27;string bar&#x27;; // 该场合可以转成数值，也可以转成字符串 case &#x27;default&#x27;: default: return &#x27;default bar&#x27;; &#125; &#125; &#125;&#125;let bar = new Bar();console.log(bar * 2); // 6console.log(bar + 2); // default bar2console.log(String(bar)); // string barconsole.log(bar == &#x27;default bar&#x27;); // true Symbol.toStringTag 一个字符串，该字符串用于创建对象的默认字符串描述。由内置方法 Object.prototype.toString()使用 123456789101112class Foo &#123;&#125;const foo = new Foo();console.log(foo.toString()); // [object Object]class Bar &#123; constructor() &#123; this[Symbol.toStringTag] = &#x27;Bar&#x27;; &#125;&#125;const bar = new Bar();console.log(bar.toString()); // [object Bar] Symbol.unscopables 一个对象，该对象所有的以及继承的属性，都会从关联对象的 with 环境绑定中排除 不推荐使用 with，因此也不推荐使用 Symbol.unscopables","categories":[],"tags":[{"name":"JavaScript高级程序设计学习笔记","slug":"JavaScript高级程序设计学习笔记","permalink":"http://ericz9.github.io/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"JavaScript高级程序设计学习笔记 - 数据类型","slug":"JavaScript高级程序设计学习笔记-数据类型","date":"2020-12-17T01:30:51.000Z","updated":"2020-12-19T04:18:07.546Z","comments":true,"path":"2020/12/17/JavaScript高级程序设计学习笔记-数据类型/","link":"","permalink":"http://ericz9.github.io/2020/12/17/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"ECMAScript中有6种原始类型：Undefined、Null、Boolean、Number、String、Symbol，一种复杂类型Object。 typeof 操作符 typeof undefined; // undefined typeof null; // object typeof &#39;hello&#39;; // string typeof 1; // number typeof true; // boolean typeof Symbol(); // symbol 类型判断从上面可以看出，typeof 可以准确的进行大部分原始类型的检测，唯一例外的是 typeof null 返回的是 object。 更严重的是，typeof 对于 Array、Date等类型均返回 object，在很多情况下，这可能并不是我们所期望的。 这时候，你也许需要 Object.prototype.toString。 12345678910111213141516171819202122232425262728293031323334/** * 类型判断 * 确保拿到的是原始类型，而不是对应的包装对象 */function getType(ele) &#123; let eleType; // 判断数据是引用类型的情况 if (typeof ele === &#x27;object&#x27;) &#123; const eleClass = Object.prototype.toString.call(ele); const eleClasses = eleClass.split(&#x27; &#x27;)[1].split(&#x27;&#x27;); eleClasses.pop(); eleType = eleClasses.join(&#x27;&#x27;).toLowerCase(); &#125; else &#123; // 判断数据是基本数据类型和函数的情况 eleType = typeof ele; &#125; return eleType;&#125;// testgetType(undefined); // undefinedgetType(null); // nullgetType(&#x27;hello&#x27;); // stringgetType(1); // numbergetType(true); // booleangetType(Symbol()); // symbolgetType(&#123;&#125;); // objectgetType([]); // arraygetType(new Date()); // dategetType(new RegExp()); // regexpgetType(function() &#123;&#125;); // functiongetType(window.JSON); // json Undefined 类型变量已声明但未初始化时，它的值就是 undefined。 12let foo;console.log(foo === undefined); // true Null 类型null 值表示一个空对象指针，这也是给typeof 传一个 null 会返回”object”的原因。 undefined 值是由 null 值派生而来的，因此 ECMA-262 将它们定义为表面上相等。 12console.log(null == undefined); // trueconsole.log(null === undefined); // false Boolean 类型Boolean 有两个字面值： true 和 false。 对于任意数据类型，都可以使用 Boolean() 转型函数获得一个布尔值，下表列出了详细的转换规则： 数据类型 转换为 true 的值 转换为 false 的值 String 非空字符串 空字符串 Number 非零数值（包括无穷值） 0、NaN Object 任意对象 null Undefined N/A（不存在） undefined Number 类型ECMAScript使用 IEEE 754 格式表示整数和浮点值，这就导致在小数运算中，经常产生舍入错误，如 console.log(0.1 + 0.2); // 0.30000000000000004 Number()、parseInt() 和 parseFloat() 都可以进行数值转换，它们的区别如下： 布尔值123456console.log(Number(true)); // 1console.log(Number(false)); // 0console.log(parseInt(true)); // NaNconsole.log(parseInt(false)); // NaNconsole.log(parseFloat(true)); // NaNconsole.log(parseFloat(false)); // NaN null 和 undefined123456console.log(Number(null)); // 0console.log(Number(undefined)); // NaNconsole.log(parseInt(null)); // NaNconsole.log(parseInt(undefined)); // NaNconsole.log(parseFloat(null)); // NaNconsole.log(parseFloat(undefined)); // NaN 字符串1234567891011121314151617181920212223242526272829303132333435// 空字符串// parseInt，如果第一个字符不是数值、加号或减号，立即返回 NaN// parseFloat同上console.log(Number(&#x27;&#x27;)); // 0console.log(parseInt(&#x27;&#x27;)); // NaNconsole.log(parseFloat(&#x27;&#x27;)); // NaN// 小数// parseInt 会取截至到小数点之前的数值console.log(Number(&#x27;1.1&#x27;)); // 1.1console.log(parseInt(&#x27;1.1&#x27;)); // 1console.log(parseFloat(&#x27;1.1&#x27;)); // 1.1// Number 和 parseFloat 始终会忽略前面的0// parseInt 则特殊一点，如果以&quot;0x&quot;开头，则被解释为16进制；如果以“0”开头且紧跟数值字符，在非严格模式下，会被某些实现解释为8进制console.log(Number(&#x27;01.1&#x27;)); // 1.1console.log(parseInt(&#x27;01.1&#x27;)); // 1console.log(parseFloat(&#x27;01.1&#x27;)); // 1.1// 包含非数值字符// parseInt 和 parseFloat 会依次检测每个字符，直到末尾，或遇到非数值字符console.log(Number(&#x27;1.1a&#x27;)); // NaNconsole.log(parseInt(&#x27;1.1a&#x27;)); // 1console.log(parseFloat(&#x27;1.1a&#x27;)); // 1.1// 以非数值、加号或减号开头，立即返回NaNconsole.log(Number(&#x27;a1.1&#x27;)); // NaNconsole.log(parseInt(&#x27;a1.1&#x27;)); // NaNconsole.log(parseFloat(&#x27;a1.1&#x27;)); // NaN// 多个小数点// 其实情况与传入的参数为 &quot;1.1a&quot; 时一致console.log(Number(&#x27;1.1.1&#x27;)); // NaNconsole.log(parseInt(&#x27;1.1.1&#x27;)); // 1console.log(parseFloat(&#x27;1.1.1&#x27;)); // 1.1 书中建议，如果明确需要转换为整数，可以优先使用 parseInt() 函数，它更专注于字符串中是否包含数值模式。 String 类型字符串属于值类型，可以使用双引号”、单引号’或反引号` 表示，一旦创建不可再改变。 1234567/** * 我们先浅显的理解一下，“一旦创建不可再改变” 不是指变量创建后不能再赋值，而是说变量所保存的值不可再改变 * 在这个示例中，在 foo 再次赋值时，会先创建一个 another value，保存到 foo，然后销毁 value * 而不是将 value 替换为 another value，这就是 “一旦创建不可再改变” 的意思 */let foo = &#x27;value&#x27;;foo = &#x27;another value&#x27;; 再看一个例子 12345678910/** * 因为 String 是值类型，所创建的变量按值访问 * 所以 foo 和 bar 都得到了 str 的一个副本，它们相互独立，互不干扰 */let str = &#x27;value&#x27;;let foo = str;let bar = str;str = &#x27;another value&#x27;;console.log(foo); // valueconsole.log(bar); // value 模板字面量技术上讲，模板字面量不是字符串，而是一种特殊的 JavaScript 表达式，只不过求值后得到的是字符串。 123// 所插入的值都会使用 toString() 强制转型为字符串const foo = &#x27;world&#x27;;console.log(`Hello $&#123;foo[0].toUpperCase()&#125;$&#123;foo.slice(1)&#125;`); // Hello World 标签函数123456789101112131415161718192021222324252627let a = 6;let b = 9;function simpleTag(strings, aValExpression, bValExpression, sumExpression) &#123; console.log(strings); console.log(aValExpression); console.log(bValExpression); console.log(sumExpression); return &#x27;foobar&#x27;;&#125;simpleTag`$&#123; a &#125; + $&#123; b &#125; = $&#123; a + b &#125;`;// 这两种调用方式是等效的// 对于有 n 个插值的模板字面量，传给标签函数的表达式参数的个数始终是 n，而传给标签函数的第一个参数所包含的字符串个数则始终是 n+1// 第一个参数的值，应是每个插值和边界的间隔：// 位置0：反引号 ` 和 插值 $&#123; a &#125; 之间的边界// 位置1：插值 $&#123; a &#125; 和 插值 $&#123; b &#125; 之间的边界// 位置2：插值 $&#123; b &#125; 和 插值 $&#123; a + b &#125; 之间的边界// 位置3：插值 $&#123; a + b &#125; 和 反引号 ` 之间的边界simpleTag([&#x27;&#x27;, &#x27; + &#x27;, &#x27; = &#x27;, &#x27;&#x27;], 6, 9, 15);// 都输出以下内容// [&quot;&quot;, &quot; + &quot;, &quot; = &quot;, &quot;&quot;]// 6// 9// 15 个人觉得标签函数的应用场景在于，输出的字符串中，有多个位置需要动态插值。而标签函数的第一个参数的个数始终是 n+1，那我们可以利用这一点，使用数组的 reduce 方法，很方便的求值。 123456789101112131415161718function encodeHTML(strings, ...values) &#123; return strings.reduce((prev, current, index) =&gt; &#123; if(index &gt; 0) &#123; const value = values[index - 1].replace(/&lt;/g,&quot;&amp;lt;&quot;).replace(/&gt;/g,&quot;&amp;gt;&quot;); prev += value; &#125; return prev + current; &#125;, &#x27;&#x27;);&#125;const badCode = &#x27;&lt;script&gt;alert(&quot;abc&quot;)&lt;/script&gt;&#x27;;const message = encodeHTML`code $&#123;badCode&#125; is safely`;// 等同于// const message = encodeHTML([&#x27;code &#x27;, &#x27; is safely&#x27;], &#x27;&lt;script&gt;alert(&quot;abc&quot;)&lt;/script&gt;&#x27;);console.log(message); // code &amp;lt;script&amp;gt;alert(&quot;abc&quot;)&amp;lt;/script&amp;gt; is safely 原始字符串使用 String.raw 或者 通过标签函数的第一个参数，可以方便的取得字符串的原始内容 12345678console.log(`\\u00A9`); // ©console.log(String.raw`\\u00A9`); // \\u00A9function encodeHTML(strings, ...values) &#123; strings.forEach((item) =&gt; &#123; console.log(item); /* © */ &#125;) strings.raw.forEach((item) =&gt; &#123; console.log(item); /* \\u00A9 */ &#125;)&#125;encodeHTML`\\u00A9`; Symbol 类型单独写一篇文章讲解 Object 类型Object 是所有对象的基类，它有几个常用属性或方法： hasOwnProperty用来确定属性是在实例上，还是在原型对象上123456function Person() &#123;&#125;;Person.prototype.name = &quot;Nicholas&quot;;let person = new Person();person.age = 20;console.log(person.hasOwnProperty(&#x27;name&#x27;)); // falseconsole.log(person.hasOwnProperty(&#x27;age&#x27;)); // true isPrototypeOf以上面代码为例，用于判断person对象的原型是否指向Person.prototype12console.log(Person.prototype.isPrototypeOf(person)); // trueconsole.log(person.__proto__ === Person.prototype); // true","categories":[],"tags":[{"name":"JavaScript高级程序设计学习笔记","slug":"JavaScript高级程序设计学习笔记","permalink":"http://ericz9.github.io/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"JavaScript高级程序设计学习笔记 - 变量声明","slug":"JavaScript高级程序设计学习笔记-变量声明","date":"2020-12-16T03:17:35.000Z","updated":"2020-12-16T06:20:59.343Z","comments":true,"path":"2020/12/16/JavaScript高级程序设计学习笔记-变量声明/","link":"","permalink":"http://ericz9.github.io/2020/12/16/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E/","excerpt":"","text":"首先要知道的是，ECMAScript 中一切都区分大小写。无论是变量、函数名还是操作符，都区分大小写。 有 3 个关键字可以声明变量：var、const 和 let。其中，var 在ECMAScript 的所有版本中都可以使用，而 const 和 let 只能在 ECMAScript 6 及更晚的版本中使用。 var 关键字使用 var 操作符定义的变量有两个特点： 局部变量，声明范围为函数作用域它的作用域意外着，该变量会在函数退出时销毁 声明自动提升声明自动提升的意思是，把所有变量声明都拉到函数作用域顶部 12345function foo() &#123; console.log(age); var age = 26;&#125;foo(); // undefined 之所以不会报错，是因为它等价于 123456function foo() &#123; var age; console.log(age); age = 26;&#125;foo(); // undefined let 声明 let 跟 var 最大的区别是，let 声明的范围是块级作用域 123456789function foo() &#123; var name = &#x27;Matt&#x27;; if (true) &#123; let age = 20; console.log(age); // 20 &#125; console.log(name); // Matt console.log(age); // ReferenceError: age is not defined&#125; let 声明的变量不会在作用域中被提升，所以在声明之前不能引用，此为“暂时性死区”（temporal dead zone） let 在全局作用域中声明的变量不会成为 window 对象的属性（var 声明的变量则会） for 循环中的 let 声明使用 var 定义的迭代变量会渗透到循环体外部 1234for (var i = 0; i &lt; 5; ++i) &#123; // 循环逻辑&#125;console.log(i); // 5 使用 let 定义的迭代变量的作用域仅限于循环内部，JavaScript 引擎在后台会为每个迭代循环声明一个新的迭代变量 1234for (let i = 0; i &lt; 5; ++i) &#123; // 循环逻辑&#125;console.log(i); // ReferenceError: i is not defined const 声明const 与 let 唯一一个重要的区别是，声明时必须同时初始化值，且后续不可再修改。 需要注意的是，这个限制只适用于它指向的变量的引用。换句话说，如果使用 const 定义了一个对象，则后续是可以再修改的。 12345678const foo = &#x27;foo&#x27;foo = &#x27;bar&#x27; // Assignment to constant variableconst bar = &#123;&#125;bar.name = &#x27;bar&#x27; // okconst baz = []baz.push(&#x27;baz&#x27;) // ok","categories":[],"tags":[{"name":"JavaScript高级程序设计学习笔记","slug":"JavaScript高级程序设计学习笔记","permalink":"http://ericz9.github.io/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"2016与2017","slug":"2016与2017","date":"2017-02-06T01:02:15.000Z","updated":"2020-12-15T01:38:29.690Z","comments":true,"path":"2017/02/06/2016与2017/","link":"","permalink":"http://ericz9.github.io/2017/02/06/2016%E4%B8%8E2017/","excerpt":"","text":"年过完了，2016也已离我们远去，本应及早提笔的年度总结计划，现在才开始动笔。而2017我也将迈入而立之年，诚惶诚恐，危机感与日俱增…… 回顾整个2016，部门的开发计划均有所参与，重构了一些系统的架构，尝试了一些新的开发方式，但真的有一个让自己特别满意的吗？恐怕是没有，有的想法还没来得及去实现，有些代码还有待优化。 刚刚吐槽了一下自己，赶紧适当的鼓励一下自己，不然就是满满的负能量了。看看今年自己都做了些啥吧 买了房，装修也开始了，也算是跟老婆有了一个自己的家 完全重写了CMS系统，易用性更好，对开发效率有了大(chui)幅(niu)提升 从商城系统衍生出一套B2B2C，整合了商户部分，提升此类工单的开发效率 终于开始写博客了，虽然到目前为止仅仅更新了6篇文章 开始勇敢的接受JavaScript知识，买了本书《JavaScript高级程序设计》 还做了一些打杂的工作 不总结不知道，一总结吓一跳。原来去年做的事情，做的还是有些随意的，赶紧写个计划来压压惊。 上半年基本上是围绕着诸葛帮来转了，虽说业务逻辑算不上很复杂，不过业务板块众多，会涉及到几个业务拆分的地方，花在数据设计、系统架构、数据互通上的时间也会很多 优化CMS系统，可能会包括开发一套移动端标准模板、后台优化、插件等功能，提升代码质量 博客继续写，至少保持一月两篇的量 上半年完成书籍《JavaScript高级程序设计》，系统的了解JavaScript这门语言。不怕读的慢，就怕读完仍知识分散。 在很久很久以前，历史与地理，一直是自己的乐趣，如今却对它们视而不见很多年，其实仍旧是有兴趣的，就是人太懒，需要借此调整自己的生活状态。 提升英语能力，争取可以在阅读英文文档、技术资料上没有太大障碍 带爸妈、岳父岳母去北京游玩 是时候考个驾照了 这就是自己对于2017年的计划了，工作方面可能会跟随部门有所调整，而自己能控制的部分，希望能把握住。干在这行，对新技术、新产品保持敏锐度，多看，多思考，勤思考。","categories":[],"tags":[{"name":"总结&计划","slug":"总结-计划","permalink":"http://ericz9.github.io/tags/%E6%80%BB%E7%BB%93-%E8%AE%A1%E5%88%92/"}]},{"title":"JavaScript高级程序设计学习笔记 - 01基本概念","slug":"JavaScript高级程序设计学习笔记-01基本概念","date":"2016-12-16T11:53:31.000Z","updated":"2020-12-15T01:38:29.690Z","comments":true,"path":"2016/12/16/JavaScript高级程序设计学习笔记-01基本概念/","link":"","permalink":"http://ericz9.github.io/2016/12/16/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-01%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","excerpt":"","text":"前端社区的轮子越造越多，作为一个后端码农，看的是眼花缭乱，很容易经不起诱惑跟随潮流去学人家的轮子。索性去当当买一本纸质书“JavaScript高级程序设计”，跟随书本静心学习（此系列文章仅为本人阅读笔记） 数据类型ECMAScript包含5种基本数据类型：Undefined、Null、Boolean、Number、String，1种复杂数据类型：Object typeof 操作符由于ECMAScript是松散类型的，typeof用于检测给定变量的数据类型 “undefined”：如果这个值未定义 “boolean”：如果这个值是布尔值 “string”：如果这个值是字符串 “number”：如果这个值是数值 “object”：如果这个值是对象或null（null被认为是一个空的对象引用） “function”：如果这个值是函数 从技术角度来讲，函数是对象，而不是一种数据类型。然而函数也确实有一些特殊的属性，因此有区分的必要。 Boolean 类型1234var message = &#x27;Hello world&#x27;;if(message)&#123; console.log(&#x27;Value is true&#x27;);&#125; 这段代码能进入if代码块的原因是，存在自动执行的Boolean转换。如可以这样转换var messageAsBoolean = Boolean(message); Number 类型使用IEEE754格式来表示整数和浮点数值，并支持十进制、八进制和十六进制。 八进制：第一位为0，其余为0-7的数字，如果其中有数字超出8，那么前导0将被忽略，后面数值当作十进制解析。（八进制字面量在严格模式下无效） 十六进制：0x开头，后跟任意十六进制数字（0-9及A-F）在进行算术计算时，所有以八进制和十六进制表示的数值都将被转换成十进制。123if(a + b == 0.3)&#123; console.log(&#x27;You got 0.3.&#x27;);&#125; *注意：永远不要做这样的测试。这是因为基于IEEE754数值的浮点计算的通病，会有舍入误差，可以使用toFixed()来解决这个问题。** 至于数值转换的三个函数：Number()、parseInt()、parseFloat()，转换规则实在太多，就不一一列举了，可参见W3school ECMAScript 类型转换 语句label 语句 与 break和continue 语句配合使用这种联合使用的情况，一般发生在循环嵌套的情况下 123456789101112var num = 0;outermost:for(var i = 0; i &lt; 10; i++)&#123; for(var j = 0; j &lt; 10; j++)&#123; if(i == 7 &amp;&amp; j == 7)&#123; break outermost; //跳出外层循环，返回77 //continue outermost; //退出内部循环，执行外部循环，返回97 &#125; num++; &#125;&#125;console.log(num);","categories":[],"tags":[{"name":"JavaScript高级程序设计学习笔记","slug":"JavaScript高级程序设计学习笔记","permalink":"http://ericz9.github.io/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"我的JavaScript学习之路 - 继承","slug":"我的JavaScript学习之路-继承","date":"2016-10-25T06:15:53.000Z","updated":"2020-12-15T01:38:29.691Z","comments":true,"path":"2016/10/25/我的JavaScript学习之路-继承/","link":"","permalink":"http://ericz9.github.io/2016/10/25/%E6%88%91%E7%9A%84JavaScript%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E7%BB%A7%E6%89%BF/","excerpt":"","text":"习惯了后端编程，对于JavaScript的面向对象处理方式，极度不适应，这个知识点的学习，还是主要来源于w3school。 实现思路使用对象冒充继承父类构造函数的属性，用原型链继承父类prototype对象的方法 概念对象冒充和原型链概念的理解 对象冒充有两个函数A和A1，A1需要继承自A。只需在A1中定义一个变量，指向A，然后调用它，A1就会得到来自A中定义的属性和方法。如： 12345678910function A(name)&#123; this.name = name;&#125;function A1(name, color)&#123; this.new = A; //执行A构造函数 this.new(name); delete this.new; this.color = color;&#125; 更简洁的方式使用call()和apply()，可以更简洁的实现继承，这两个方法的作用相同，就是参数不同。 12fun.call(thisArg[, arg1[, arg2[, ...]]])fun.apply(thisArg, [argsArray]) 可以看到这两个方法的第一个参数是一样的，区别在于call从第二个参数开始，后面有许多参数；而apply的第二个参数接受一个数组。这两个方法的作用在于改变函数的作用域，使调用的构造函数的this指向为我们传递过去的对象。 所以我们可以这样做： 123456789function A1(name, color)&#123; A.call(this, name); this.color = color;&#125;//或者function A1(name, color)&#123; A.apply(this, [name]); this.color = color;&#125; 原型链ECMAScript中描述了原型链的概念，并将原型链作为实现继承的主要方法。其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。当查找一个对象属性时，会先在该对象实例中查找，如果没有找到，则会向上遍历原型链，如果一直没有找到，则最终会遍历到Object.prototype。这也是为什么所有的JavaScript对象都具有Object的基本方法。 这里把A1的prototype设置成A的实例，这样一来，A1将会得到A实例的所有属性。当然你也逐个设置prototype的值，但显然赋值为一个实例化对象来的更简单。注意：1: 这里调用A构造函数的时候，并没有给它传递参数。这在原型链中是标准做法，要确保构造函数没有任何参数。 (这只是标准做法，其实传递参数也没有问题，当你完全用原型链来实现继承的时候，对应的继承属性的值默认就是你传递过去的值，只不过它存在于对象的__proto__属性中。)2: 原型链的方式不支持多重继承，因为会用另一类型的对象重写prototype属性。 1A1.prototype = new A(); 实现在上一次的”JavaScript对象”文章中，提到了创建类的最好方式是用构造函数定义属性，用原型定义方法，这种方式仍然适应于继承机制，使用对象冒充继承构造函数的属性，用原型链继承对象的方法。 12345function A1(name, color)&#123; A.call(this, name); this.color = color;&#125;A1.prototype = new A();","categories":[],"tags":[{"name":"JavaScript学习之路","slug":"JavaScript学习之路","permalink":"http://ericz9.github.io/tags/JavaScript%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"}]},{"title":"微信小程序开发之数据请求","slug":"微信小程序开发之数据请求","date":"2016-10-21T08:38:29.000Z","updated":"2020-12-15T01:38:29.690Z","comments":true,"path":"2016/10/21/微信小程序开发之数据请求/","link":"","permalink":"http://ericz9.github.io/2016/10/21/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E4%B9%8B%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82/","excerpt":"","text":"最近在开发微信小程序的时候，发现使用wx.request进行POST请求时，始终获取不到传递过来的值，查询的时候发现网上还有说只能识别https请求，其实并不是。 其实很简单 设置method为POST 设置Content-Type为application/x-www-form-urlencoded data参数不能再写为Object形式，需转为类似QueryString格式 1234567891011wx.request(&#123; url: &#x27;http://www.demo.com/api/case&#x27;, data: util.json2Form(paramObject), method: &#x27;POST&#x27;, header: &#123; &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded; charset=UTF-8&#x27; &#125;, success: function(res)&#123; console.log(res); &#125;&#125;) 1234567function json2Form(json) &#123; var str = []; for(var p in json)&#123; str.push(encodeURIComponent(p) + &quot;=&quot; + encodeURIComponent(json[p])); &#125; return str.join(&quot;&amp;&quot;); &#125; PS: 其实也不能说是官方文档的问题，只是现在请求头中Content-Type为application/json的格式，有些服务端还不被支持。例如我服务端是使用C#来构建的，如果要解析的话，需要使用Request.InputStream，而不能用Request.Form来获取。","categories":[],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://ericz9.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"vscode 快捷键","slug":"vscode快捷键","date":"2016-10-20T07:37:02.000Z","updated":"2020-12-15T01:38:29.690Z","comments":true,"path":"2016/10/20/vscode快捷键/","link":"","permalink":"http://ericz9.github.io/2016/10/20/vscode%E5%BF%AB%E6%8D%B7%E9%94%AE/","excerpt":"","text":"很喜欢vscode这个编辑器，由于工作中使用visual studio居多，使用起来还是不太熟练，好记性还是不如烂笔头啊…… Ctrl + D: 选中光标所在单词，多次按下可以选中所有相同的单词Ctrl + P: 打开转到文件小窗口，可在输入框中输入”?”号执行其他快捷操作Ctrl + B: 显示/隐藏侧边栏Alt + Shift + F: 整理代码格式","categories":[],"tags":[{"name":"vscode","slug":"vscode","permalink":"http://ericz9.github.io/tags/vscode/"}]},{"title":"我的JavaScript学习之路 - JavaScript对象","slug":"我的JavaScript学习之路-JavaScript对象","date":"2016-09-29T08:27:04.000Z","updated":"2020-12-15T01:38:29.691Z","comments":true,"path":"2016/09/29/我的JavaScript学习之路-JavaScript对象/","link":"","permalink":"http://ericz9.github.io/2016/09/29/%E6%88%91%E7%9A%84JavaScript%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-JavaScript%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"原文 对象是指带有属性和方法的特殊数据类型如何创建对象 创建直接的实例 方式一12var person = new Object();person.age = 24; 方式二1var person = &#123; age : 24 &#125;; 使用对象构造器12345function person(age)&#123; this.age = age;&#125;;var me = new person(24); for…in循环123456for(var x in person)&#123; //输出 age console.log(x); //输出 24 console.log(person[x]);&#125; JavaScript类JavaScript是面向对象的语言，但不使用类，而是基于构造函数和prototypeECMAScript定义类或对象的几种方式 一般使用的两种方式：混合构造函数/原型方式、动态原型方式 混合构造函数/原型方式 联合构造函数和原型方式，就可以像其他程序语言一样创建对象。这种概念非常简单，即用构造函数定义对象的所有非函数属性，用原型方式定义对象的函数属性（方法）。结果是，所有的函数只创建一遍，而每个对象又都具有自己的对象属性实例。 123456789function Person(age)&#123; this.age = age;&#125;Person.prototype.introAge = function()&#123; console.log(&#x27;my age is &#x27; + this.age);&#125;;var oPerson = new Person(24);console.log(oPerson.age);console.log(oPerson.introAge()); 动态原型方式 动态原型方式的基本想法与上述方式相同，唯一的区别在于赋予对象方法的位置，以达到对属性和方法进行视觉上的封装。 1234567891011121314function Person(age)&#123; this.age = age; //使用&quot;_initialized&quot;作为标记，来判断是否已给原型赋予了方法 if(typeof Person._initialized == &#x27;undefined&#x27;)&#123; Person.prototype.introAge = function()&#123; console.log(&#x27;my age is &#x27; + this.age); &#125;; Person._initialized = true; &#125;&#125;var oPerson = new Person(24);console.log(oPerson.age);console.log(oPerson.introAge());","categories":[],"tags":[{"name":"JavaScript学习之路","slug":"JavaScript学习之路","permalink":"http://ericz9.github.io/tags/JavaScript%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"}]},{"title":"使用GitHub Pages和hexo搭建我的个人博客","slug":"使用GitHub-Pages和hexo搭建我的个人博客","date":"2016-09-29T08:17:31.000Z","updated":"2020-12-15T01:38:29.690Z","comments":true,"path":"2016/09/29/使用GitHub-Pages和hexo搭建我的个人博客/","link":"","permalink":"http://ericz9.github.io/2016/09/29/%E4%BD%BF%E7%94%A8GitHub-Pages%E5%92%8Chexo%E6%90%AD%E5%BB%BA%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"参考文章：Hexo官方文档CrazyMilk：GitHub Pages + Hexo搭建博客luckykun：hexo搭建属于自己的博客知乎：使用hexo，如果换了电脑怎么更新博客？ 使用主题：Yilia","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"JavaScript高级程序设计学习笔记","slug":"JavaScript高级程序设计学习笔记","permalink":"http://ericz9.github.io/tags/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"总结&计划","slug":"总结-计划","permalink":"http://ericz9.github.io/tags/%E6%80%BB%E7%BB%93-%E8%AE%A1%E5%88%92/"},{"name":"JavaScript学习之路","slug":"JavaScript学习之路","permalink":"http://ericz9.github.io/tags/JavaScript%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"},{"name":"微信小程序","slug":"微信小程序","permalink":"http://ericz9.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"vscode","slug":"vscode","permalink":"http://ericz9.github.io/tags/vscode/"}]}