{"meta":{"title":"ericz9's blog","subtitle":"再出发","description":null,"author":"ericz9","url":"http://ericz9.github.io","root":"/"},"pages":[{"title":"Categories","date":"2020-12-16T03:10:00.000Z","updated":"2020-12-16T03:10:50.617Z","comments":false,"path":"categories/index.html","permalink":"http://ericz9.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2015-08-16T06:58:08.000Z","updated":"2020-12-16T03:11:01.852Z","comments":true,"path":"about/index.html","permalink":"http://ericz9.github.io/about/index.html","excerpt":"HipaperA fashional newspaper, blog theme for Hexo. ☞ Preview Demo | 查看中文使用文档","text":"HipaperA fashional newspaper, blog theme for Hexo. ☞ Preview Demo | 查看中文使用文档 Installation Get it from GitHub 1$ git clone https://github.com/iTimeTraveler/hexo-theme-hipaper.git themes/hipaper Enable Modify theme setting in _config.yml to hipaper. 1234# Extensions## Plugins: http:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F;## Themes: http:&#x2F;&#x2F;hexo.io&#x2F;themes&#x2F;theme: hipaper Update 12$ cd themes/hipaper$ git pull FeaturesLogo: Image or TextYou can set a image as your logo instead of original text title. Like this: just enable avatar field in hipaper/_config.yml. 12345678# Put your avatar.jpg into `hexo-site/themes/hipaper/source/` directory.# url is target link (E.g. `url: https://hexo.io/logo.svg` or `url: css/images/mylogo.jpg`)avatar: enable: true width: 124 height: 124 bottom: 10 url: https://hexo.io/logo.svg Code HighlightHipaper use Tomorrow Theme for your code block. We have six options in total: default, normal, night, night blue, night bright, night eighties Above preview picture is default theme. the image below show other five Highlight themes. Modify highlight_theme in hipaper/_config.yml. 12345# Code Highlight theme# Available value:# default | normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: default SidebarYou can put your sidebar in left side, right side or bottom of your site by editing sidebar setting.Hipaper provides 7 built-in widgets: search social recent_posts category tag tagcloud archive All of them are enabled by default. You can edit them in widget setting. SearchHipaper use Insight Search to help you search anything inside your site without any third-party plugin. 12345# Searchsearch: insight: true # you need to install `hexo-generator-json-content` before using Insight Search swiftype: # enter swiftype install key here baidu: false # you need to disable other search engines to use Baidu search, options: true, false Attention: You need to install hexo-generator-json-content before using Insight Search. 1$ npm install -S hexo-generator-json-content FancyboxHipaper uses Fancybox to showcase your photos. You can use Markdown syntax or fancybox tag plugin to add your photos. 123![img caption](img url)&#123;% fancybox img_url [img_thumbnail] [img_caption] %&#125; Comment supportHipaper has native support for DuoShuo &amp; Disqus comment systems. Modify the following snippets to Hipaper hipaper/_config.yml: 123# comment ShortName, you can choose only ONE to display.duoshuo_shortname: iTimeTravelerdisqus_shortname: Browser support ContributingAll kinds of contributions (enhancements, new features, documentation &amp; code improvements, issues &amp; bugs reporting) are welcome. Looking forward to your pull request. Special thanks to ATHEMES, who designed the original theme FASHIONISTA for Wordpress. LicenseHipaper is under the MIT license. See the LICENSE file for details."},{"title":"Tags","date":"2020-12-16T03:10:00.000Z","updated":"2020-12-16T03:10:55.759Z","comments":true,"path":"tags/index.html","permalink":"http://ericz9.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JavaScript高级程序设计学习笔记 - 集合引用类型(Array)","slug":"JavaScript高级程序设计学习笔记-集合引用类型-Array","date":"2020-12-29T00:34:50.000Z","updated":"2020-12-29T03:42:50.825Z","comments":true,"path":"2020/12/29/JavaScript高级程序设计学习笔记-集合引用类型-Array/","link":"","permalink":"http://ericz9.github.io/2020/12/29/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E9%9B%86%E5%90%88%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-Array/","excerpt":"","text":"尽量使用字面量的方式创建数组 创建数组123456789101112131415let arr1 = new Array(3); // [undefined, undefined, undefined]let arr2 = [3]; // [3]const obj = &#123; &#x27;0&#x27;: &#x27;a&#x27;, &#x27;1&#x27;: &#x27;b&#x27;, length: 2&#125;// 将类数组结构转换为数组实例// 它也可以转换只有 length 属性但不具备 iterator的结构，而 ... 拓展运算符做不到这一点let arr3 = Array.from(obj); // [&quot;a&quot;, &quot;b&quot;]let arr4 = [...obj]; // obj is not iterable// 把一组参数转换为数组let arr5 = Array.of(&#x27;a&#x27;, &#x27;b&#x27;); // [&quot;a&quot;, &quot;b&quot;] 检测数组1Array.isArray([]); // true 迭代器方法12345678910111213141516const arr = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;, &quot;qux&quot;];console.log([...arr.keys()]); // [0, 1, 2, 3]console.log([...arr.values()]); // [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;, &quot;qux&quot;]console.log([...arr.entries()]); // [Array(2), Array(2), Array(2), Array(2)]for (const [idx, element] of arr.entries()) &#123; console.log(idx); console.log(element); &#125;// 0// foo// 1// bar// 2// baz// 3// qux 复制与填充fill 向数组中插入指定值 123456789101112const zeroes = [0, 0, 0, 0, 0];// 用 5 填充整个数组console.log(zeroes.fill(5)); // [5, 5, 5, 5, 5]zeroes.fill(0); // 重置// 用 6 填充索引大于等于 3 的元素console.log(zeroes.fill(6, 3)); // [0, 0, 0, 6, 6]zeroes.fill(0); // 重置// 用 7 填充索引大于等于 1 且小于 3 的元素console.log(zeroes.fill(7, 1, 3)); // [0, 7, 7, 0, 0] copyWithin 按照指定范围浅复制数组中的部分内容，然后将它们插入到指定索引开始的位置 栈方法与队列方法栈是 LIFO 结构（后进先出） push：添加到数组末尾，返回最新长度 pop：移除数组最后一项，返回被移除项 队列是 FIFO 结构（先进先出） unshift：添加到数组开头，返回最新长度 shift：移除数组第一项，返回被移除项 排序 reverse()：降序（用的很少） sort()：默认升序。排序时，对每一项使用 String() 转型函数，然后比较字符串来决定顺序 sort((a, b) =&gt; a - b)：升序 sort((a, b) =&gt; b - a)：降序 操作方法 concat：合并数组，返回新数组 slice：切分数组，返回新数组。不包含结束索引的元素 splice：插入、删除或替换数组，返回删除的元素组成的数组，会修改原数组 搜素和位置方法 indexOf：从前向后搜索，返回元素在数组中的索引，未找到返回 -1 lastIndexOf：从后向前搜索，返回元素在数组中的索引，未找到返回 -1 includes：是否包含至少一个匹配项，返回布尔值 find：返回第一个匹配的项 findIndex：返回第一个匹配项的索引 迭代方法对数组的每一项，都运行传入的函数 every：如果都返回 true，则返回 true filter：返回结果为 true 的数组 forEach：没有返回值 map：返回每次函数调用所返回的结果的数组 some：某一项返回 true，则返回 true 归并方法 reduce：从第一项开始，遍历到最后一项 reduceRight：从最后一项开始，遍历到第一项归并方法接收两个参数：对每一项都会运行的归并函数，以及可选的以之为归并起点的初始值1234567891011121314151617let values = [1, 2, 3, 4, 5];// prev：上一个归并值// cur：当前项// index：当前项的索引// array：和数组本身let sum = values.reduce(function(prev, cur, index, array) &#123; console.log(prev, cur); return prev + cur;&#125;, 100);// 100 1// 101 2// 103 3// 106 4// 110 5console.log(sum); // 115","categories":[],"tags":[{"name":"红宝书","slug":"红宝书","permalink":"http://ericz9.github.io/tags/%E7%BA%A2%E5%AE%9D%E4%B9%A6/"},{"name":"红宝书第6章（集合引用类）","slug":"红宝书第6章（集合引用类）","permalink":"http://ericz9.github.io/tags/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E7%AC%AC6%E7%AB%A0%EF%BC%88%E9%9B%86%E5%90%88%E5%BC%95%E7%94%A8%E7%B1%BB%EF%BC%89/"}]},{"title":"JavaScript高级程序设计学习笔记 - 位操作符","slug":"JavaScript高级程序设计学习笔记-位操作符","date":"2020-12-24T01:21:53.000Z","updated":"2020-12-28T03:41:27.525Z","comments":true,"path":"2020/12/24/JavaScript高级程序设计学习笔记-位操作符/","link":"","permalink":"http://ericz9.github.io/2020/12/24/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6/","excerpt":"","text":"位操作可以直接操作内存中表示数据的比特位。ECMAScript 中的数值都以 IEEE 754 64位格式存储，但位操作是先把值转换为 32 位整数，再进行位操作，之后再把结果转换为 64 位。 有符号整数使用 32 位的前 31 位表示整数值。第 32 位表示数值的符号，如 0 表示正，1 表示负。这一位称为符号位（sign bit），它的值决定了数值其余部分的格式。 原码、反码和补码 反码即一补数，补码即二补数 正数的原码、反码、补码是一致的 负数的补码是反码加1，反码就是对原码按位取反，但是符号位不变 运算都是基于补码的 按位非对数值取反并减1 12345let num1 = 25; // 二进制 00000000000000000000000000011001let num2 = ~num1; // 二进制 11111111111111111111111111100110let num3 = -num1 - 1;console.log(num2); // -26console.log(num3); // -26 按位与两个位都是 1 时返回 1，任一位是 0 时返回 0 123456// 25: 0000 0000 0000 0000 0000 0000 0001 1001// 3: 0000 0000 0000 0000 0000 0000 0000 0011// -------------------------------------------// =: 0000 0000 0000 0000 0000 0000 0000 0001let result = 25 &amp; 3;console.log(result); // 1 按位或至少一位是 1 时返回 1，两位都是 0 时返回 0 123456// 25: 0000 0000 0000 0000 0000 0000 0001 1001// 3: 0000 0000 0000 0000 0000 0000 0000 0011// -------------------------------------------// =: 0000 0000 0000 0000 0000 0000 0001 1011let result = 25 | 3;console.log(result); // 27 按位异或一位上是 1 的时候返回 1，两位都是 1 或 0，则返回 0 123456// 25: 0000 0000 0000 0000 0000 0000 0001 1001// 3: 0000 0000 0000 0000 0000 0000 0000 0011// -------------------------------------------// =: 0000 0000 0000 0000 0000 0000 0001 1010let result = 25 ^ 3;console.log(result); // 26 左移按指定的位数，将数值的所有位向左移动。移位后，右边的空位以 0 填充 12let oldValue = 2; // 等于二进制 10let newValue = oldValue &lt;&lt; 5; // 等于二进制 1000000，即十进制 64 有符号右移将数值的所有 32 位都向右移，同时保留符号（正或负）。移位后，左边的空位以符号位的值填充 12let oldValue = 64; // 等于二进制 1000000let newValue = oldValue &gt;&gt; 5; // 等于二进制 10，即十进制 2 无符号右移将数值的所有 32 位都向右移。移位后，左边的空位以 0 填充，而不管符号位是正数还是负数 12let oldValue = 64; // 等于二进制 1000000let newValue = oldValue &gt;&gt;&gt; 5; // 等于二进制 10，即十进制 2","categories":[],"tags":[{"name":"红宝书","slug":"红宝书","permalink":"http://ericz9.github.io/tags/%E7%BA%A2%E5%AE%9D%E4%B9%A6/"},{"name":"红宝书第3章（语言基础）","slug":"红宝书第3章（语言基础）","permalink":"http://ericz9.github.io/tags/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E7%AC%AC3%E7%AB%A0%EF%BC%88%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%EF%BC%89/"}]},{"title":"JavaScript高级程序设计学习笔记 - 基本引用类型","slug":"JavaScript高级程序设计学习笔记-基本引用类型","date":"2020-12-23T02:25:19.000Z","updated":"2020-12-24T01:32:52.513Z","comments":true,"path":"2020/12/23/JavaScript高级程序设计学习笔记-基本引用类型/","link":"","permalink":"http://ericz9.github.io/2020/12/23/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E6%9C%AC%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"本文主要介绍 Date、RegExp 和 Math 的 API 方法 Date创建日期对象123const foo = new Date(); // 当前时间const bar = new Date(Date.now()); // 基于毫秒数创建，Date.now() 返回当前时间的毫秒数const baz = new Date(&#x27;12/23/2020&#x27;); // 基于日期创建（月/日/年） 格式化1234567const foo = new Date(&#x27;12/23/2020&#x27;); // 基于日期创建（月/日/年）console.log(foo.toString()); // Wed Dec 23 2020 00:00:00 GMT+0800 (中国标准时间)console.log(foo.toLocaleString()); // 2020/12/23 上午12:00:00console.log(foo.toDateString()); // Wed Dec 23 2020console.log(foo.toLocaleDateString()); // 2020/12/23console.log(foo.toTimeString()); // 00:00:00 GMT+0800 (中国标准时间)console.log(foo.toLocaleTimeString()); // 上午12:00:00 其他方法12345678910111213141516171819202122232425262728293031323334353637// ISO 8601 扩展格式“YYYY-MM-DDTHH:mm:ss.sssZ”，如 2019-05-23T00:00:00（只适用于兼容 ES5 的实现）const foo = new Date(&#x27;2020-12-23T11:12:12.678&#x27;);// 日期的毫秒表示foo.getTime(); // 1608693132000foo.setTime();// 4位数年foo.getFullYear(); // 2020foo.setFullYear();// 日期中的月（0 - 11）foo.getMonth(); // 11foo.setMonth();// 日期中的日（1 - 31）foo.getDate(); // 23foo.setDate();// 日期中的周几（0（周日） - 6）foo.getDay(); // 3// 日期中的时（0 - 23）foo.getHours(); // 11foo.setHours();// 日期中的分（0 - 59）foo.getMinutes(); // 12foo.setMinutes();// 日期中的秒（0 - 59）foo.getSeconds(); // 12foo.setSeconds();// 日期中的毫秒foo.getMilliseconds(); // 678foo.setMilliseconds(); RegExp正则表达式可以使用字面量或构造函数来创建，它们是等效的。 123const foo = &#x27;foobar&#x27;;const pattern1 = /bar/g;const pattern2 = new RegExp(&#x27;bar&#x27;, &#x27;g&#x27;); 匹配标记 g：全局匹配 i：不区分大小写 m：多行搜索 y：粘附模式，表示只查找从 lastIndex 开始及之后的字符串 u：使用 unicode 进行匹配 s：允许 . 匹配换行符 特殊字符 字符 含义 示例 ^ 匹配输入的开始 /^A/.test(&#39;aA&#39;); // false /^A/.test(&#39;Aa&#39;); // true $ 匹配输入的结束 /A$/.test(&#39;aA&#39;); // true /A$/.test(&#39;Aa&#39;); // false * 匹配前一个表达式 0 次或多次，等价于 {0,} + 匹配前面一个表达式 1 次或多次，等价于 {1,} ? 匹配前面一个表达式 0 次或 1 次，等价于 {0,1} . 默认匹配除换行符之外的任何单个字符 x|y 匹配 x 或 y {n} n 是一个正整数，匹配前面一个字符刚好出现了 n 次 {n,} n是一个正整数，匹配前一个字符至少出现了n次 {n,m} n 和 m 都是整数。匹配前面的字符至少n次，最多m次。如果 n 或者 m 的值是0， 这个值被忽略 [xyz] 匹配方括号中的任意字符 [^xyz] 匹配任何没有包含在方括号中的字符 \\d 匹配一个数字，等价于[0-9] \\D 匹配一个非数字字符，等价于[^0-9] \\n 匹配一个换行符 \\r 匹配一个回车符 \\s 匹配一个空白字符，包括空格、制表符、换页符和换行符 \\S 匹配一个非空白字符 \\w 匹配一个单字字符（字母、数字或者下划线）。等价于 [A-Za-z0-9_] \\W 匹配一个非单字字符。等价于 [^A-Za-z0-9_] Math最大值与最小值12console.log(Math.min(3, 54, 32, 16)); //3console.log(Math.max(3, 54, 32, 16)); //54 舍入12345678910const foo = 2.49;// 向上舍入为最接近的整数console.log(Math.ceil(foo)); // 3// 向下舍入为最接近的整数console.log(Math.floor(foo)); // 2// 四舍五入console.log(Math.round(foo)); // 2 随机数1console.log(Math.random()); // 返回 0 到 1 范围内的随机数 table th:first-child { width: 50px; }","categories":[],"tags":[{"name":"红宝书","slug":"红宝书","permalink":"http://ericz9.github.io/tags/%E7%BA%A2%E5%AE%9D%E4%B9%A6/"},{"name":"红宝书第5章（基本引用类型）","slug":"红宝书第5章（基本引用类型）","permalink":"http://ericz9.github.io/tags/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E7%AC%AC5%E7%AB%A0%EF%BC%88%E5%9F%BA%E6%9C%AC%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%89/"}]},{"title":"JavaScript高级程序设计学习笔记 - 变量复制","slug":"JavaScript高级程序设计学习笔记-变量复制","date":"2020-12-22T01:59:11.000Z","updated":"2020-12-24T01:31:56.121Z","comments":true,"path":"2020/12/22/JavaScript高级程序设计学习笔记-变量复制/","link":"","permalink":"http://ericz9.github.io/2020/12/22/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8F%98%E9%87%8F%E5%A4%8D%E5%88%B6/","excerpt":"","text":"我们已经知道，ECMAScript 中包含两种类型的数据：原始值和引用值。其中，原始值按值访问，引用值按引用访问。 按值访问和按引用访问首先我们需要了解原始值和引用值的内存分配机制： 原始值：存储在栈（stack）中 引用值：有指针和实际值，实际的值存储在堆（heap）中，指针存储在栈中，它指向实际的值所存储的地址 而不同的内存分配，也就出现了上面所说的两种不同的访问机制 原始值我们可以直接从栈中获取，这就是按值访问 而引用值，我们需要先在栈中得到它所指向的实际地址，然后根据该地址获得实际的值，这就是按引用访问 只有按值传递先说结论，所有变量的复制，都是按值传递，没有按引用传递一说 复制原始值：产生一个副本，它们没有任何关系，完全独立，互不干扰 复制引用值： 实际就是复制指针，产生一个副本，两个指针之间没有任何关系，完全独立，互不干扰 两个指针的值都是该引用值的实际地址 1234567891011121314let foo = &#123; name: &#x27;foo&#x27; &#125;;let bar = foo;console.log(foo === bar); // true// 因为两个指针都指向同一个地址，所以改变 bar 的 name，foo 中也会同步改变bar.name = &#x27;foo changed&#x27;;console.log(foo.name); // foo changedconsole.log(bar.name); // foo changed// 因为是按值传递，两个指针相互独立，给 bar 赋值，会重新产生一个指针，指向 bar 实际的值的地址// 如果是按引用传递，foo 也应被改变才对bar = &#123; name: &#x27;bar&#x27; &#125;;console.log(foo.name); // foo changedconsole.log(bar.name); // bar 理解 JS 中只有按值传递的重点在于，复制原始值时会在栈中产生一个实际值的副本，复制引用值时会在栈中产生一个指针的副本（指针是独立的，但都指向实际的值所在堆中的同一个地址）。函数的参数传递也是如此。","categories":[],"tags":[{"name":"红宝书","slug":"红宝书","permalink":"http://ericz9.github.io/tags/%E7%BA%A2%E5%AE%9D%E4%B9%A6/"},{"name":"红宝书第4章（变量、作用域与内存）","slug":"红宝书第4章（变量、作用域与内存）","permalink":"http://ericz9.github.io/tags/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%EF%BC%89/"}]},{"title":"JavaScript高级程序设计学习笔记 - 数据类型(Symbol)","slug":"JavaScript高级程序设计学习笔记-数据类型-Symbol","date":"2020-12-21T01:50:17.000Z","updated":"2020-12-24T01:32:33.679Z","comments":true,"path":"2020/12/21/JavaScript高级程序设计学习笔记-数据类型-Symbol/","link":"","permalink":"http://ericz9.github.io/2020/12/21/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-Symbol/","excerpt":"","text":"Symbol（符号） 是原始值，其实例是唯一、不可变的，它的用途是用做对象的非字符串形式的属性，而不会产生同名冲突。 符号初始化12345678// 符号需要使用 Symbol() 函数初始化let genericSymbol = Symbol();let otherGenericSymbol = Symbol();console.log(genericSymbol == otherGenericSymbol); // false let fooSymbol = Symbol(&#x27;foo&#x27;);let otherFooSymbol = Symbol(&#x27;foo&#x27;);console.log(fooSymbol == otherFooSymbol); // false 全局符号使用 Symbol.for() 创建全局符号，它是一个幂等操作。 123let globalSymbol = Symbol.for(&#x27;foo&#x27;); // 创建全局符号let otherGlobalSymbol = Symbol.for(&#x27;foo&#x27;); // 重用已定义的全局符号console.log(globalSymbol === otherGlobalSymbol); // true 符号属性12345678910111213141516171819202122232425let fooSymbol = Symbol(&#x27;foo&#x27;);let barSymbol = Symbol(&#x27;bar&#x27;);let bazSymbol = Symbol(&#x27;baz&#x27;);let quxSymbol = Symbol(&#x27;qux&#x27;);let o = &#123; foo: &#x27;foo&#x27;, [fooSymbol]: &#x27;foo symbol&#x27;&#125;;Object.defineProperty(o, barSymbol, &#123; value: &#x27;bar symbol&#x27; &#125;);Object.defineProperties(o, &#123; [bazSymbol]: &#123; value: &#x27;baz symbol&#x27; &#125;, [quxSymbol]: &#123; value: &#x27;qux symbol&#x27; &#125;&#125;);// 返回常规属性console.log(Object.getOwnPropertyNames(o)); // [&#x27;foo&#x27;]// 返回符号属性console.log(Object.getOwnPropertySymbols(o)); // [Symbol(foo), Symbol(bar), Symbol(baz), Symbol(qux)]// 返回常规属性和符号属性console.log(Reflect.ownKeys(o)); // [&quot;foo&quot;, Symbol(foo), Symbol(bar), Symbol(baz), Symbol(qux)] 常用内置符号内置符号就是全局函数 Symbol 的普通字符串属性，指向一个符号的实例，它们最重要的用途是方便开发者重新定义，从而改变原生结构行为。 Symbol.asyncIterator 一个方法，该方法返回对象默认的 AsyncIterator。由 for-await-of 语句使用 Symbol.hasInstance 一个方法，该方法决定一个构造器对象是否认可一个对象是它的实例。由 instanceof 操作符使用 在 ES6 中，instanceof 操作符会使用 Symbol.hasInstance 函数来确定关系，它定义在 Function 的原型上，因此可以在类的静态方法中定义 12345678class Foo &#123; static [Symbol.hasInstance]() &#123; return false; &#125;&#125;let foo = new Foo();console.log(foo instanceof Foo); // false Symbol.isConcatSpreadable 一个布尔值，如果是 true，则意味着对象应该用 Array.prototype.concat()打平其数组元素 12345let foo = [&#x27;foo&#x27;];let bar = [&#x27;bar&#x27;];bar[Symbol.isConcatSpreadable] = false;console.log(foo.concat(bar)); // [&#x27;foo&#x27;, Array(1)] Symbol.iterator 一个方法，该方法返回对象默认的迭代器。由 for-of 语句使用 Symbol.match 一个正则表达式方法，该方法用正则表达式去匹配字符串。由 String.prototype.match()方法使用 12345678910111213141516console.log(&#x27;foobar&#x27;.match(/bar/)); // [&quot;bar&quot;, index: 3, input: &quot;foobar&quot;, groups: undefined]class StringMatcher &#123; constructor(str) &#123; this.str = str; &#125; /** * 重新定义 Symbol.match 函数，从而让 match() 方法可以使用非正则表达式实例 * @param &#123;String&#125; target 调用 match() 方法的字符串 */ [Symbol.match](target) &#123; return target.includes(this.str); &#125;&#125;console.log(&#x27;foobar&#x27;.match(new StringMatcher(&#x27;bar&#x27;))); // true Symbol.replace 一个正则表达式方法，该方法替换一个字符串中匹配的子串。由 String.prototype.replace()方法使用 123456789101112131415class StringReplacer &#123; constructor(str) &#123; this.str = str; &#125; /** * 重新定义 Symbol.replace 函数，从而让 replace() 方法可以使用非正则表达式实例 * @param &#123;String&#125; target 调用 replace() 方法的字符串 * @param &#123;String&#125; replacement 被替换后的值 */ [Symbol.replace](target, replacement) &#123; return target.split(this.str).join(replacement); &#125;&#125;console.log(&#x27;barfoobaz&#x27;.replace(new StringReplacer(&#x27;foo&#x27;), &#x27;qux&#x27;)); // &quot;barquxbaz&quot; Symbol.search 一个正则表达式方法，该方法返回字符串中匹配正则表达式的索引。由 String.prototype.search()方法使用 1234567891011121314class StringSearcher &#123; constructor(str) &#123; this.str = str; &#125; /** * 重新定义 Symbol.search 函数，从而让 search() 方法可以使用非正则表达式实例 * @param &#123;String&#125; target 调用 search() 方法的字符串 */ [Symbol.search](target) &#123; return target.indexOf(this.str); &#125;&#125;console.log(&#x27;foobar&#x27;.search(new StringSearcher(&#x27;foo&#x27;))); // 0 Symbol.species 一个函数值，该函数作为创建派生对象的构造函数 它的意义在于，子类返回基类的实例，而非子类的实例 1234567891011class Foo extends Promise &#123;&#125;class Bar extends Promise &#123; // 指向基类 Promise 的实例 static get [Symbol.species]() &#123; return Promise; &#125;&#125;console.log(new Foo(r =&gt; r()).then(v =&gt; v) instanceof Foo) // trueconsole.log(new Bar(r =&gt; r()).then(v =&gt; v) instanceof Bar) // false Symbol.split 一个正则表达式方法，该方法在匹配正则表达式的索引位置拆分字符串。由 String.prototype.split()方法使用 1234567891011121314class StringSplitter &#123; constructor(str) &#123; this.str = str; &#125; /** * 重新定义 Symbol.split 函数，从而让 split() 方法可以使用非正则表达式实例 * @param &#123;String&#125; target 调用 split() 方法的字符串 */ [Symbol.split](target) &#123; return target.split(this.str); &#125;&#125;console.log(&#x27;barfoobaz&#x27;.split(new StringSplitter(&#x27;foo&#x27;))); // [&quot;bar&quot;, &quot;baz&quot;] Symbol.toPrimitive 一个方法，该方法将对象转换为相应的原始值。由 ToPrimitive 抽象操作使用 很多内置操作的场景下，会将对象强制转换为原始值，这时候我们可以使用该内置符号改变默认行为 12345678910111213141516171819202122232425class Bar &#123; constructor() &#123; // 支持三种模式（string、number、default） this[Symbol.toPrimitive] = function(hint) &#123; switch (hint) &#123; // 该场合需转换成数值 case &#x27;number&#x27;: return 3; // 该场合需转换成字符串 case &#x27;string&#x27;: return &#x27;string bar&#x27;; // 该场合可以转成数值，也可以转成字符串 case &#x27;default&#x27;: default: return &#x27;default bar&#x27;; &#125; &#125; &#125;&#125;let bar = new Bar();console.log(bar * 2); // 6console.log(bar + 2); // default bar2console.log(String(bar)); // string barconsole.log(bar == &#x27;default bar&#x27;); // true Symbol.toStringTag 一个字符串，该字符串用于创建对象的默认字符串描述。由内置方法 Object.prototype.toString()使用 123456789101112class Foo &#123;&#125;const foo = new Foo();console.log(foo.toString()); // [object Object]class Bar &#123; constructor() &#123; this[Symbol.toStringTag] = &#x27;Bar&#x27;; &#125;&#125;const bar = new Bar();console.log(bar.toString()); // [object Bar] Symbol.unscopables 一个对象，该对象所有的以及继承的属性，都会从关联对象的 with 环境绑定中排除 不推荐使用 with，因此也不推荐使用 Symbol.unscopables","categories":[],"tags":[{"name":"红宝书","slug":"红宝书","permalink":"http://ericz9.github.io/tags/%E7%BA%A2%E5%AE%9D%E4%B9%A6/"},{"name":"红宝书第3章（语言基础）","slug":"红宝书第3章（语言基础）","permalink":"http://ericz9.github.io/tags/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E7%AC%AC3%E7%AB%A0%EF%BC%88%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%EF%BC%89/"}]},{"title":"JavaScript高级程序设计学习笔记 - 数据类型","slug":"JavaScript高级程序设计学习笔记-数据类型","date":"2020-12-17T01:30:51.000Z","updated":"2020-12-24T01:32:31.588Z","comments":true,"path":"2020/12/17/JavaScript高级程序设计学习笔记-数据类型/","link":"","permalink":"http://ericz9.github.io/2020/12/17/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"ECMAScript中有6种原始类型：Undefined、Null、Boolean、Number、String、Symbol，一种复杂类型Object。 typeof 操作符 typeof undefined; // undefined typeof null; // object typeof &#39;hello&#39;; // string typeof 1; // number typeof true; // boolean typeof Symbol(); // symbol 类型判断从上面可以看出，typeof 可以准确的进行大部分原始类型的检测，唯一例外的是 typeof null 返回的是 object。 更严重的是，typeof 对于 Array、Date等类型均返回 object，在很多情况下，这可能并不是我们所期望的。 这时候，你也许需要 Object.prototype.toString。 12345678910111213141516171819202122232425262728293031323334/** * 类型判断 * 确保拿到的是原始类型，而不是对应的包装对象 */function getType(ele) &#123; let eleType; // 判断数据是引用类型的情况 if (typeof ele === &#x27;object&#x27;) &#123; const eleClass = Object.prototype.toString.call(ele); const eleClasses = eleClass.split(&#x27; &#x27;)[1].split(&#x27;&#x27;); eleClasses.pop(); eleType = eleClasses.join(&#x27;&#x27;).toLowerCase(); &#125; else &#123; // 判断数据是基本数据类型和函数的情况 eleType = typeof ele; &#125; return eleType;&#125;// testgetType(undefined); // undefinedgetType(null); // nullgetType(&#x27;hello&#x27;); // stringgetType(1); // numbergetType(true); // booleangetType(Symbol()); // symbolgetType(&#123;&#125;); // objectgetType([]); // arraygetType(new Date()); // dategetType(new RegExp()); // regexpgetType(function() &#123;&#125;); // functiongetType(window.JSON); // json Undefined 类型变量已声明但未初始化时，它的值就是 undefined。 12let foo;console.log(foo === undefined); // true Null 类型null 值表示一个空对象指针，这也是给typeof 传一个 null 会返回”object”的原因。 undefined 值是由 null 值派生而来的，因此 ECMA-262 将它们定义为表面上相等。 12console.log(null == undefined); // trueconsole.log(null === undefined); // false Boolean 类型Boolean 有两个字面值： true 和 false。 对于任意数据类型，都可以使用 Boolean() 转型函数获得一个布尔值，下表列出了详细的转换规则： 数据类型 转换为 true 的值 转换为 false 的值 String 非空字符串 空字符串 Number 非零数值（包括无穷值） 0、NaN Object 任意对象 null Undefined N/A（不存在） undefined Number 类型ECMAScript使用 IEEE 754 格式表示整数和浮点值，这就导致在小数运算中，经常产生舍入错误，如 console.log(0.1 + 0.2); // 0.30000000000000004 Number()、parseInt() 和 parseFloat() 都可以进行数值转换，它们的区别如下： 布尔值123456console.log(Number(true)); // 1console.log(Number(false)); // 0console.log(parseInt(true)); // NaNconsole.log(parseInt(false)); // NaNconsole.log(parseFloat(true)); // NaNconsole.log(parseFloat(false)); // NaN null 和 undefined123456console.log(Number(null)); // 0console.log(Number(undefined)); // NaNconsole.log(parseInt(null)); // NaNconsole.log(parseInt(undefined)); // NaNconsole.log(parseFloat(null)); // NaNconsole.log(parseFloat(undefined)); // NaN 字符串1234567891011121314151617181920212223242526272829303132333435// 空字符串// parseInt，如果第一个字符不是数值、加号或减号，立即返回 NaN// parseFloat同上console.log(Number(&#x27;&#x27;)); // 0console.log(parseInt(&#x27;&#x27;)); // NaNconsole.log(parseFloat(&#x27;&#x27;)); // NaN// 小数// parseInt 会取截至到小数点之前的数值console.log(Number(&#x27;1.1&#x27;)); // 1.1console.log(parseInt(&#x27;1.1&#x27;)); // 1console.log(parseFloat(&#x27;1.1&#x27;)); // 1.1// Number 和 parseFloat 始终会忽略前面的0// parseInt 则特殊一点，如果以&quot;0x&quot;开头，则被解释为16进制；如果以“0”开头且紧跟数值字符，在非严格模式下，会被某些实现解释为8进制console.log(Number(&#x27;01.1&#x27;)); // 1.1console.log(parseInt(&#x27;01.1&#x27;)); // 1console.log(parseFloat(&#x27;01.1&#x27;)); // 1.1// 包含非数值字符// parseInt 和 parseFloat 会依次检测每个字符，直到末尾，或遇到非数值字符console.log(Number(&#x27;1.1a&#x27;)); // NaNconsole.log(parseInt(&#x27;1.1a&#x27;)); // 1console.log(parseFloat(&#x27;1.1a&#x27;)); // 1.1// 以非数值、加号或减号开头，立即返回NaNconsole.log(Number(&#x27;a1.1&#x27;)); // NaNconsole.log(parseInt(&#x27;a1.1&#x27;)); // NaNconsole.log(parseFloat(&#x27;a1.1&#x27;)); // NaN// 多个小数点// 其实情况与传入的参数为 &quot;1.1a&quot; 时一致console.log(Number(&#x27;1.1.1&#x27;)); // NaNconsole.log(parseInt(&#x27;1.1.1&#x27;)); // 1console.log(parseFloat(&#x27;1.1.1&#x27;)); // 1.1 书中建议，如果明确需要转换为整数，可以优先使用 parseInt() 函数，它更专注于字符串中是否包含数值模式。 String 类型字符串属于值类型，可以使用双引号”、单引号’或反引号` 表示，一旦创建不可再改变。 1234567/** * 我们先浅显的理解一下，“一旦创建不可再改变” 不是指变量创建后不能再赋值，而是说变量所保存的值不可再改变 * 在这个示例中，在 foo 再次赋值时，会先创建一个 another value，保存到 foo，然后销毁 value * 而不是将 value 替换为 another value，这就是 “一旦创建不可再改变” 的意思 */let foo = &#x27;value&#x27;;foo = &#x27;another value&#x27;; 再看一个例子 12345678910/** * 因为 String 是值类型，所创建的变量按值访问 * 所以 foo 和 bar 都得到了 str 的一个副本，它们相互独立，互不干扰 */let str = &#x27;value&#x27;;let foo = str;let bar = str;str = &#x27;another value&#x27;;console.log(foo); // valueconsole.log(bar); // value 模板字面量技术上讲，模板字面量不是字符串，而是一种特殊的 JavaScript 表达式，只不过求值后得到的是字符串。 123// 所插入的值都会使用 toString() 强制转型为字符串const foo = &#x27;world&#x27;;console.log(`Hello $&#123;foo[0].toUpperCase()&#125;$&#123;foo.slice(1)&#125;`); // Hello World 标签函数123456789101112131415161718192021222324252627let a = 6;let b = 9;function simpleTag(strings, aValExpression, bValExpression, sumExpression) &#123; console.log(strings); console.log(aValExpression); console.log(bValExpression); console.log(sumExpression); return &#x27;foobar&#x27;;&#125;simpleTag`$&#123; a &#125; + $&#123; b &#125; = $&#123; a + b &#125;`;// 这两种调用方式是等效的// 对于有 n 个插值的模板字面量，传给标签函数的表达式参数的个数始终是 n，而传给标签函数的第一个参数所包含的字符串个数则始终是 n+1// 第一个参数的值，应是每个插值和边界的间隔：// 位置0：反引号 ` 和 插值 $&#123; a &#125; 之间的边界// 位置1：插值 $&#123; a &#125; 和 插值 $&#123; b &#125; 之间的边界// 位置2：插值 $&#123; b &#125; 和 插值 $&#123; a + b &#125; 之间的边界// 位置3：插值 $&#123; a + b &#125; 和 反引号 ` 之间的边界simpleTag([&#x27;&#x27;, &#x27; + &#x27;, &#x27; = &#x27;, &#x27;&#x27;], 6, 9, 15);// 都输出以下内容// [&quot;&quot;, &quot; + &quot;, &quot; = &quot;, &quot;&quot;]// 6// 9// 15 个人觉得标签函数的应用场景在于，输出的字符串中，有多个位置需要动态插值。而标签函数的第一个参数的个数始终是 n+1，那我们可以利用这一点，使用数组的 reduce 方法，很方便的求值。 123456789101112131415161718function encodeHTML(strings, ...values) &#123; return strings.reduce((prev, current, index) =&gt; &#123; if(index &gt; 0) &#123; const value = values[index - 1].replace(/&lt;/g,&quot;&amp;lt;&quot;).replace(/&gt;/g,&quot;&amp;gt;&quot;); prev += value; &#125; return prev + current; &#125;, &#x27;&#x27;);&#125;const badCode = &#x27;&lt;script&gt;alert(&quot;abc&quot;)&lt;/script&gt;&#x27;;const message = encodeHTML`code $&#123;badCode&#125; is safely`;// 等同于// const message = encodeHTML([&#x27;code &#x27;, &#x27; is safely&#x27;], &#x27;&lt;script&gt;alert(&quot;abc&quot;)&lt;/script&gt;&#x27;);console.log(message); // code &amp;lt;script&amp;gt;alert(&quot;abc&quot;)&amp;lt;/script&amp;gt; is safely 原始字符串使用 String.raw 或者 通过标签函数的第一个参数，可以方便的取得字符串的原始内容 12345678console.log(`\\u00A9`); // ©console.log(String.raw`\\u00A9`); // \\u00A9function encodeHTML(strings, ...values) &#123; strings.forEach((item) =&gt; &#123; console.log(item); /* © */ &#125;) strings.raw.forEach((item) =&gt; &#123; console.log(item); /* \\u00A9 */ &#125;)&#125;encodeHTML`\\u00A9`; Symbol 类型单独写一篇文章讲解 Object 类型Object 是所有对象的基类，它有几个常用属性或方法： hasOwnProperty用来确定属性是在实例上，还是在原型对象上123456function Person() &#123;&#125;;Person.prototype.name = &quot;Nicholas&quot;;let person = new Person();person.age = 20;console.log(person.hasOwnProperty(&#x27;name&#x27;)); // falseconsole.log(person.hasOwnProperty(&#x27;age&#x27;)); // true isPrototypeOf以上面代码为例，用于判断person对象的原型是否指向Person.prototype12console.log(Person.prototype.isPrototypeOf(person)); // trueconsole.log(person.__proto__ === Person.prototype); // true","categories":[],"tags":[{"name":"红宝书","slug":"红宝书","permalink":"http://ericz9.github.io/tags/%E7%BA%A2%E5%AE%9D%E4%B9%A6/"},{"name":"红宝书第3章（语言基础）","slug":"红宝书第3章（语言基础）","permalink":"http://ericz9.github.io/tags/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E7%AC%AC3%E7%AB%A0%EF%BC%88%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%EF%BC%89/"}]},{"title":"JavaScript高级程序设计学习笔记 - 变量声明","slug":"JavaScript高级程序设计学习笔记-变量声明","date":"2020-12-16T03:17:35.000Z","updated":"2020-12-24T01:32:11.059Z","comments":true,"path":"2020/12/16/JavaScript高级程序设计学习笔记-变量声明/","link":"","permalink":"http://ericz9.github.io/2020/12/16/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E/","excerpt":"","text":"首先要知道的是，ECMAScript 中一切都区分大小写。无论是变量、函数名还是操作符，都区分大小写。 有 3 个关键字可以声明变量：var、const 和 let。其中，var 在ECMAScript 的所有版本中都可以使用，而 const 和 let 只能在 ECMAScript 6 及更晚的版本中使用。 var 关键字使用 var 操作符定义的变量有两个特点： 局部变量，声明范围为函数作用域它的作用域意外着，该变量会在函数退出时销毁 声明自动提升声明自动提升的意思是，把所有变量声明都拉到函数作用域顶部 12345function foo() &#123; console.log(age); var age = 26;&#125;foo(); // undefined 之所以不会报错，是因为它等价于 123456function foo() &#123; var age; console.log(age); age = 26;&#125;foo(); // undefined let 声明 let 跟 var 最大的区别是，let 声明的范围是块级作用域 123456789function foo() &#123; var name = &#x27;Matt&#x27;; if (true) &#123; let age = 20; console.log(age); // 20 &#125; console.log(name); // Matt console.log(age); // ReferenceError: age is not defined&#125; let 声明的变量不会在作用域中被提升，所以在声明之前不能引用，此为“暂时性死区”（temporal dead zone） let 在全局作用域中声明的变量不会成为 window 对象的属性（var 声明的变量则会） for 循环中的 let 声明使用 var 定义的迭代变量会渗透到循环体外部 1234for (var i = 0; i &lt; 5; ++i) &#123; // 循环逻辑&#125;console.log(i); // 5 使用 let 定义的迭代变量的作用域仅限于循环内部，JavaScript 引擎在后台会为每个迭代循环声明一个新的迭代变量 1234for (let i = 0; i &lt; 5; ++i) &#123; // 循环逻辑&#125;console.log(i); // ReferenceError: i is not defined const 声明const 与 let 唯一一个重要的区别是，声明时必须同时初始化值，且后续不可再修改。 需要注意的是，这个限制只适用于它指向的变量的引用。换句话说，如果使用 const 定义了一个对象，则后续是可以再修改的。 12345678const foo = &#x27;foo&#x27;foo = &#x27;bar&#x27; // Assignment to constant variableconst bar = &#123;&#125;bar.name = &#x27;bar&#x27; // okconst baz = []baz.push(&#x27;baz&#x27;) // ok","categories":[],"tags":[{"name":"红宝书","slug":"红宝书","permalink":"http://ericz9.github.io/tags/%E7%BA%A2%E5%AE%9D%E4%B9%A6/"},{"name":"红宝书第3章（语言基础）","slug":"红宝书第3章（语言基础）","permalink":"http://ericz9.github.io/tags/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E7%AC%AC3%E7%AB%A0%EF%BC%88%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%EF%BC%89/"}]},{"title":"vscode 快捷键","slug":"vscode快捷键","date":"2016-10-20T07:37:02.000Z","updated":"2020-12-15T01:38:29.690Z","comments":true,"path":"2016/10/20/vscode快捷键/","link":"","permalink":"http://ericz9.github.io/2016/10/20/vscode%E5%BF%AB%E6%8D%B7%E9%94%AE/","excerpt":"","text":"很喜欢vscode这个编辑器，由于工作中使用visual studio居多，使用起来还是不太熟练，好记性还是不如烂笔头啊…… Ctrl + D: 选中光标所在单词，多次按下可以选中所有相同的单词Ctrl + P: 打开转到文件小窗口，可在输入框中输入”?”号执行其他快捷操作Ctrl + B: 显示/隐藏侧边栏Alt + Shift + F: 整理代码格式","categories":[],"tags":[{"name":"vscode","slug":"vscode","permalink":"http://ericz9.github.io/tags/vscode/"}]}],"categories":[],"tags":[{"name":"红宝书","slug":"红宝书","permalink":"http://ericz9.github.io/tags/%E7%BA%A2%E5%AE%9D%E4%B9%A6/"},{"name":"红宝书第6章（集合引用类）","slug":"红宝书第6章（集合引用类）","permalink":"http://ericz9.github.io/tags/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E7%AC%AC6%E7%AB%A0%EF%BC%88%E9%9B%86%E5%90%88%E5%BC%95%E7%94%A8%E7%B1%BB%EF%BC%89/"},{"name":"红宝书第3章（语言基础）","slug":"红宝书第3章（语言基础）","permalink":"http://ericz9.github.io/tags/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E7%AC%AC3%E7%AB%A0%EF%BC%88%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%EF%BC%89/"},{"name":"红宝书第5章（基本引用类型）","slug":"红宝书第5章（基本引用类型）","permalink":"http://ericz9.github.io/tags/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E7%AC%AC5%E7%AB%A0%EF%BC%88%E5%9F%BA%E6%9C%AC%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%89/"},{"name":"红宝书第4章（变量、作用域与内存）","slug":"红宝书第4章（变量、作用域与内存）","permalink":"http://ericz9.github.io/tags/%E7%BA%A2%E5%AE%9D%E4%B9%A6%E7%AC%AC4%E7%AB%A0%EF%BC%88%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%EF%BC%89/"},{"name":"vscode","slug":"vscode","permalink":"http://ericz9.github.io/tags/vscode/"}]}